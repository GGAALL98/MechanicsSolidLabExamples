<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goby Buckling Lab 2026</title>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-core: #0b0c15;
            --panel-bg: rgba(30, 32, 45, 0.9);
            --panel-border: rgba(255, 255, 255, 0.15);
            --accent-cyan: #00f2ff;
            --accent-pink: #ff0055;
            --accent-yellow: #ffcc00;
            --accent-purple: #bd00ff;
            --text-bright: #ffffff;
            --text-dim: #94a3b8;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg-core);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(189, 0, 255, 0.08) 0%, transparent 60%),
                radial-gradient(circle at 90% 80%, rgba(0, 242, 255, 0.08) 0%, transparent 60%);
            color: var(--text-bright);
            font-family: 'Inter', sans-serif;
            margin: 0; padding: 25px;
            min-height: 100vh;
            display: flex; flex-direction: column;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 350px 1fr 1fr;
            grid-template-rows: auto 350px 1fr;
            gap: 20px;
            width: 100%;
            max-width: 1800px;
            margin: 0 auto;
            flex: 1;
        }

        .header {
            grid-column: 1 / -1;
            display: flex; align-items: center; justify-content: center; /* Centered Title */
            padding-bottom: 15px; border-bottom: 1px solid var(--panel-border);
            margin-bottom: 10px;
        }

        .logo {
            font-weight: 900; font-size: 2rem; letter-spacing: -1px;
            background: linear-gradient(90deg, #00f2ff, #bd00ff, #ff0055);
            background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: holoShift 8s linear infinite;
            text-align: center;
        }
        @keyframes holoShift { 0% { background-position: 0% center; } 100% { background-position: 200% center; } }

        .panel {
            background: var(--panel-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border); border-radius: 12px;
            padding: 20px; display: flex; flex-direction: column;
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
            transition: border-color 0.2s;
        }
        .panel:hover { border-color: rgba(255,255,255,0.3); }

        h2 {
            font-size: 0.85rem; letter-spacing: 1.5px; text-transform: uppercase;
            color: var(--text-dim); margin: 0 0 20px 0;
            border-bottom: 1px solid var(--panel-border); padding-bottom: 10px;
        }

        .sidebar { grid-column: 1 / 2; grid-row: 2 / 4; }
        .control-group { margin-bottom: 15px; }
        label { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--accent-cyan); margin-bottom: 8px; font-weight: 600; }
        .val-disp { font-family: 'JetBrains Mono'; color: var(--text-bright); background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; }

        input[type="range"] {
            width: 100%; cursor: pointer; height: 6px; background: rgba(255,255,255,0.1);
            appearance: none; border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: var(--accent-purple); box-shadow: 0 0 10px var(--accent-purple);
        }

        select, input[type="number"] {
            width: 100%; background: rgba(0,0,0,0.3); border: 1px solid var(--panel-border);
            color: white; padding: 10px; border-radius: 6px; font-family: 'JetBrains Mono'; outline: none; font-size: 0.9rem;
        }
        
        .math-box {
            margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); 
            border-radius: 8px; border: 1px solid var(--panel-border);
            font-size: 0.9rem; text-align: center; overflow-x: auto;
        }

        .telemetry { margin-top: 15px; display: flex; flex-direction: column; gap: 8px; }
        .tele-row {
            display: flex; justify-content: space-between; padding: 10px;
            background: rgba(255,255,255,0.03); border-radius: 6px;
            border-left: 3px solid var(--panel-border);
        }
        .tele-lbl { font-size: 0.75rem; color: var(--text-dim); font-weight: 700; }
        .tele-val { font-family: 'JetBrains Mono'; font-weight: 700; }
        .tele-row.warn { border-left-color: var(--accent-yellow); }
        .tele-row.crit { border-left-color: var(--accent-pink); background: rgba(255,0,85,0.1); }

        .vis-container {
            grid-column: 2 / 4; grid-row: 2 / 3;
            position: relative; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.2);
        }
        #beamCanvas { width: 100%; height: 100%; }

        .scale-toggle {
            position: absolute; top: 15px; right: 15px;
            display: flex; align-items: center; gap: 8px;
            background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 20px;
            border: 1px solid var(--panel-border); cursor: pointer;
            font-size: 0.75rem; font-weight: 700; color: var(--text-dim);
            transition: 0.3s; z-index: 10;
        }
        .scale-toggle.active { border-color: var(--accent-pink); color: var(--accent-pink); }
        .scale-dot { width: 8px; height: 8px; border-radius: 50%; background: #444; }
        .scale-toggle.active .scale-dot { background: var(--accent-pink); }

        .chart-left { grid-column: 2 / 3; grid-row: 3 / 4; }
        .chart-right { grid-column: 3 / 4; grid-row: 3 / 4; }
        .chart-box { position: relative; width: 100%; height: 100%; min-height: 300px; }

        @media (max-width: 1100px) {
            .dashboard { grid-template-columns: 1fr; grid-template-rows: auto; display: flex; flex-direction: column; }
            .vis-container { height: 300px; }
            .chart-box { height: 300px; }
        }
    </style>
</head>
<body>

<div class="dashboard">
    <div class="header">
        <div class="logo">GOBY BUCKLING LAB</div>
    </div>

    <!-- CONFIGURATION SIDEBAR -->
    <aside class="panel sidebar">
        <h2>System Parameters</h2>
        
        <div class="control-group">
            <label>Boundary Conditions</label>
            <select id="bcSelect" onchange="updateSim()">
                <option value="pin-pin">Pinned-Pinned (n=1)</option>
                <option value="fixed-pin">Fixed-Pinned (nâ‰ˆ2.045)</option>
                <option value="fixed-fixed">Fixed-Fixed (n=4)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Beam Length (L)</label>
            <select id="lenSelect" onchange="updateSim()">
                <option value="345">345 mm</option>
                <option value="400" selected>400 mm</option>
                <option value="450">450 mm</option>
            </select>
        </div>

        <div class="control-group">
            <label>Cross Section (b x h) [mm]</label>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <input type="number" id="widthInput" value="20" placeholder="Width" oninput="updateSim()">
                <input type="number" id="thickInput" value="3" placeholder="Thick" oninput="updateSim()">
            </div>
        </div>

        <div class="control-group">
            <label>Imperfection (e) <span id="eDisplay" class="val-disp">0.5 mm</span></label>
            <input type="range" id="eInput" min="0.1" max="5.0" step="0.1" value="0.5" oninput="updateSim()">
        </div>

        <div class="control-group">
            <label>Applied Load (P) <span id="pDisplay" class="val-disp">0 N</span></label>
            <!-- Range will be dynamic -->
            <input type="range" id="pInput" min="0" max="800" step="1" value="0" oninput="updateSim()">
        </div>

        <div id="mathBox" class="math-box"></div>

        <div class="telemetry">
            <div class="tele-row">
                <span class="tele-lbl">EFFECTIVE LENGTH (Le)</span>
                <span class="tele-val" id="leVal">---</span>
            </div>
            <div class="tele-row warn">
                <span class="tele-lbl">CRITICAL LOAD (Pcr)</span>
                <span class="tele-val" id="pcrVal">---</span>
            </div>
            <div class="tele-row">
                <span class="tele-lbl">DEFLECTION (v)</span>
                <span class="tele-val" id="vVal">---</span>
            </div>
            <div class="tele-row" id="statusRow">
                <span class="tele-lbl">STATUS</span>
                <span class="tele-val" id="statusVal">STABLE</span>
            </div>
        </div>
    </aside>

    <!-- BEAM VISUALIZER -->
    <section class="panel vis-container">
        <div style="position:absolute; top:15px; left:15px; font-weight:700; color:var(--accent-cyan); font-size:0.9rem;">
            REAL-TIME DEFORMATION
        </div>
        
        <div class="scale-toggle" onclick="toggleScale()" id="scaleBtn">
            <div class="scale-dot"></div>
            10x MODE
        </div>

        <canvas id="beamCanvas"></canvas>
    </section>

    <!-- CHART 1: FORCE vs DEFLECTION -->
    <section class="panel chart-left">
        <h2>Force-Deflection Curve</h2>
        <div class="chart-box"><canvas id="loadDefChart"></canvas></div>
    </section>

    <!-- CHART 2: SOUTHWELL PLOT -->
    <section class="panel chart-right">
        <h2>Southwell Plot (Linear Analysis)</h2>
        <div class="chart-box"><canvas id="southwellChart"></canvas></div>
    </section>
</div>

<script>
    let beamCtx;
    let charts = {};
    const E_MODULUS = 210000; // Steel: 210 GPa
    let scaleMultiplier = 1;

    function init() {
        const canvas = document.getElementById('beamCanvas');
        beamCtx = canvas.getContext('2d');
        resizeCanvas();
        window.addEventListener('resize', () => { resizeCanvas(); updateSim(); });

        initCharts();
        updateSim();
    }

    function toggleScale() {
        scaleMultiplier = (scaleMultiplier === 1) ? 10 : 1;
        document.getElementById('scaleBtn').classList.toggle('active', scaleMultiplier === 10);
        updateSim();
    }

    function resizeCanvas() {
        const canvas = document.getElementById('beamCanvas');
        canvas.width = canvas.parentElement.offsetWidth;
        canvas.height = canvas.parentElement.offsetHeight;
    }

    function initCharts() {
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.borderColor = 'rgba(255,255,255,0.08)';

        const opts = (xTitle, yTitle) => ({
            responsive: true, maintainAspectRatio: false,
            plugins: { legend: { display: true, position: 'top', labels: { boxWidth: 10, font: { size: 10 } } } },
            scales: { 
                x: { 
                    type: 'linear',
                    position: 'bottom',
                    title: { display: true, text: xTitle, color: '#00f2ff' }, 
                    grid: { color: 'rgba(255,255,255,0.05)' },
                    min: 0
                }, 
                y: { 
                    title: { display: true, text: yTitle, color: '#bd00ff' }, 
                    grid: { color: 'rgba(255,255,255,0.05)' },
                    min: 0
                }
            },
            animation: false
        });

        // Use scatter type to ensure numerical X-axis mapping
        // Standard Load-Deflection: Deflection (X) vs Load (Y)
        charts.loadDef = new Chart(document.getElementById('loadDefChart'), {
            type: 'scatter', 
            data: { datasets: [] },
            options: opts('Lateral Deflection v [mm]', 'Axial Load P [N]')
        });

        charts.southwell = new Chart(document.getElementById('southwellChart'), {
            type: 'scatter', 
            data: { datasets: [] },
            options: opts('v/P [mm/N]', 'v [mm]')
        });
    }

    function updateSim() {
        const bc = document.getElementById('bcSelect').value;
        const L = parseFloat(document.getElementById('lenSelect').value);
        const b = parseFloat(document.getElementById('widthInput').value);
        const h = parseFloat(document.getElementById('thickInput').value);
        const e = parseFloat(document.getElementById('eInput').value);
        const pInput = document.getElementById('pInput');
        let P_target = parseFloat(pInput.value);

        const I = (b * Math.pow(h, 3)) / 12;
        let K = 1.0;
        if (bc === 'fixed-pin') K = 0.7;
        if (bc === 'fixed-fixed') K = 0.5;
        const Le = K * L;
        const Pcr = (Math.PI**2 * E_MODULUS * I) / (Le**2);

        // Clamp Logic: Hard limit at Pcr for simulation safety
        // Ensure slider respects Pcr visibly
        // We set the slider max to slightly above Pcr to show the limit, but clamp internal value
        // Update slider max dynamically to handle different beam configs
        pInput.max = Math.ceil(Pcr * 1.1); 
        
        let isBuckled = false;
        
        // STRICT CLAMP to avoid explosion - Cap at 98%
        if (P_target >= Pcr * 0.98) {
             P_target = Pcr * 0.98; // Cap just below to avoid infinity/NaN
             pInput.value = P_target; // Snap slider back visually
             isBuckled = true;
        }

        document.getElementById('eDisplay').innerText = e.toFixed(1) + " mm";
        document.getElementById('pDisplay').innerText = Math.round(P_target) + " N";

        // Theoretical Deflection at Target Load
        // v = e / (1 - P/Pcr) - e
        let v_target = 0;
        if (e > 0 && P_target < Pcr) {
            v_target = e * ( (1 / (1 - P_target/Pcr)) - 1 );
        } else if (P_target >= Pcr) {
            // Should be handled by clamp, but just in case
            v_target = 100; 
        }
        
        // Clamp v_target for display if it gets absurd (though P clamping handles most)
        if (v_target > 1000) v_target = 1000;

        document.getElementById('pcrVal').innerText = Pcr.toFixed(1) + " N";
        document.getElementById('vVal').innerText = v_target.toFixed(2) + " mm";
        document.getElementById('leVal').innerText = Le.toFixed(1) + " mm";
        
        const statusRow = document.getElementById('statusRow');
        const statusVal = document.getElementById('statusVal');
        if (isBuckled || P_target >= Pcr * 0.98) {
            statusRow.className = "tele-row crit";
            statusVal.innerText = "CRITICAL / BUCKLED";
        } else if (P_target >= Pcr * 0.7) {
            statusRow.className = "tele-row warn";
            statusVal.innerText = "APPROACHING Pcr";
        } else {
            statusRow.className = "tele-row";
            statusVal.innerText = "STABLE";
        }

        // Render Equations for Pcr and Le
        // Added Le equation as requested
        let kStr = "1";
        if(K === 0.7) kStr = "0.7";
        if(K === 0.5) kStr = "0.5";
        
        const latexStr = `
            \\begin{aligned}
            L_e &= ${kStr} \\cdot L = ${Le.toFixed(1)} \\text{ mm} \\\\
            P_{cr} &= \\frac{\\pi^2 EI}{L_e^2} = ${Pcr.toFixed(1)} \\text{ N}
            \\end{aligned}
        `;
        katex.render(latexStr, document.getElementById('mathBox'), { displayMode: true });

        // GENERATE CURVE
        const dataTheoryCurve = [];
        const dataSouthwell = [];
        const asymptoteLine = [];
        
        // Curve Plotting: Go slightly PAST Pcr on Y axis to show asymptote
        // We plot up to maxV_Plot = 100mm to show the curve flattening out completely
        const maxV_Plot = 100; 
        
        // Asymptote line (Horizontal at Y=Pcr)
        asymptoteLine.push({x: 0, y: Pcr}, {x: maxV_Plot, y: Pcr});

        // Generate theoretical P vs v curve
        // We iterate v to get P to ensure smooth curve near asymptote
        // P = Pcr * v / (e + v)
        // Step size 0.5mm is fine for 100mm range
        for(let v_plot = 0; v_plot <= maxV_Plot; v_plot += 0.5) {
            let p_plot = 0;
            if (e > 0) {
                p_plot = Pcr * (v_plot / (e + v_plot));
            } else {
                // Ideal column: P=0 until v=0, then P=Pcr.
                // We just show line at v=0 up to Pcr.
                p_plot = Pcr; 
            }
            
            // X=v, Y=P
            dataTheoryCurve.push({ x: v_plot, y: p_plot });
            
            // Southwell: X=v/P, Y=v
            if (p_plot > 2 && v_plot > 0.05) {
                dataSouthwell.push({ x: v_plot / p_plot, y: v_plot });
            }
        }

        // Update Load-Deflection Chart
        charts.loadDef.data.datasets = [
            {
                label: `Theoretical (L=${L})`,
                data: dataTheoryCurve,
                borderColor: '#bd00ff',
                borderWidth: 3,
                showLine: true,
                pointRadius: 0,
                fill: false,
                tension: 0.1
            },
            {
                label: `Asymptote (Pcr)`,
                data: asymptoteLine,
                borderColor: 'rgba(255,255,255,0.3)',
                borderWidth: 1,
                borderDash: [5,5],
                showLine: true,
                pointRadius: 0
            },
            {
                label: `Current`,
                data: [{x: v_target, y: P_target}],
                backgroundColor: '#ffffff',
                pointRadius: 6,
                pointHoverRadius: 8
            }
        ];
        
        // Dynamically adjust X scale to keep "future" curve visible
        // Always show at least up to 20mm or current v + buffer
        charts.loadDef.options.scales.x.max = Math.max(20, v_target + 10);
        charts.loadDef.options.scales.y.max = Pcr * 1.15; 
        charts.loadDef.update();

        // Update Southwell Chart
        charts.southwell.data.datasets = [
            {
                label: 'Simulation Data',
                data: dataSouthwell,
                backgroundColor: '#00f2ff',
                pointRadius: 3
            }
        ];
        charts.southwell.update();

        drawBeam(L, v_target, bc, P_target);
    }

    function drawBeam(L, v, bc, P) {
        const w = beamCtx.canvas.width;
        const h = beamCtx.canvas.height;
        beamCtx.clearRect(0, 0, w, h);

        const margin = 80;
        const beamLenPx = w - 2*margin;
        const startX = margin;
        const endX = w - margin;
        const midY = h/2;

        // Visual Scaling with 10x Mode Support
        // Base scale: 1mm deflection = (Canvas Width / L) pixels
        let basePxPerMm = beamLenPx / L;
        let pxPerMm = basePxPerMm * scaleMultiplier;
        
        let rawDeflect = v * pxPerMm;
        
        // Clamp visual deflection smoothly to avoid glitches
        const maxVisualPx = h * 0.35;
        // Use tanh for smooth clamping
        let visualDeflect = maxVisualPx * Math.tanh(rawDeflect / maxVisualPx);

        // Grid lines
        beamCtx.strokeStyle = 'rgba(255,255,255,0.05)';
        beamCtx.lineWidth = 1;
        for(let i=0; i<w; i+=50) { beamCtx.beginPath(); beamCtx.moveTo(i, 0); beamCtx.lineTo(i, h); beamCtx.stroke(); }

        // Ghost reference
        beamCtx.beginPath();
        beamCtx.moveTo(startX, midY);
        beamCtx.lineTo(startX + beamLenPx, midY);
        beamCtx.strokeStyle = 'rgba(255,255,255,0.1)';
        beamCtx.stroke();

        // Beam
        beamCtx.beginPath();
        beamCtx.moveTo(startX, midY);
        for (let i = 0; i <= beamLenPx; i++) {
            let xNorm = i / beamLenPx; 
            let yShape = 0;
            if (bc === 'pin-pin') yShape = Math.sin(Math.PI * xNorm);
            else if (bc === 'fixed-fixed') yShape = 0.5 * (1 - Math.cos(2 * Math.PI * xNorm));
            else if (bc === 'fixed-pin') yShape = (Math.pow(xNorm, 2) * (1 - xNorm)) / 0.148;

            beamCtx.lineTo(startX + i, midY + yShape * visualDeflect);
        }

        beamCtx.strokeStyle = '#00f2ff';
        beamCtx.lineWidth = 6;
        beamCtx.shadowBlur = 15;
        beamCtx.shadowColor = '#00f2ff';
        beamCtx.stroke();
        beamCtx.shadowBlur = 0;

        // Supports
        beamCtx.fillStyle = '#666';
        if(bc.includes('fixed')) {
            beamCtx.fillRect(startX - 10, midY - 30, 10, 60);
        } else {
            beamCtx.beginPath();
            beamCtx.moveTo(startX, midY); beamCtx.lineTo(startX-10, midY+15); beamCtx.lineTo(startX+10, midY+15);
            beamCtx.closePath(); beamCtx.fill();
        }

        // Right side support
        if(bc === 'fixed-fixed') {
             beamCtx.fillRect(endX, midY - 30, 10, 60); // Wall block
        } else {
             beamCtx.beginPath();
             beamCtx.moveTo(endX, midY); beamCtx.lineTo(endX-10, midY+15); beamCtx.lineTo(endX+10, midY+15);
             beamCtx.closePath(); beamCtx.fill();
        }

        // Right side load arrow
        if(P > 0) {
            const arrowLen = 40 + (P / 3);
            const arrowHead = 10;
            const arrowStart = endX + 15; 
            const arrowEnd = arrowStart + arrowLen;

            beamCtx.strokeStyle = '#ff0055';
            beamCtx.fillStyle = '#ff0055';
            beamCtx.lineWidth = 3;
            
            beamCtx.beginPath();
            beamCtx.moveTo(arrowEnd, midY);
            beamCtx.lineTo(endX, midY); // Touch support
            beamCtx.stroke();

            // Head
            beamCtx.beginPath();
            beamCtx.moveTo(endX, midY);
            beamCtx.lineTo(endX+10, midY-6);
            beamCtx.lineTo(endX+10, midY+6);
            beamCtx.closePath();
            beamCtx.fill();
            
            beamCtx.font = "bold 12px JetBrains Mono";
            beamCtx.fillText(`${Math.round(P)}N`, arrowEnd + 5, midY + 5);
        }
    }

    window.onload = init;
</script>

</body>
</html>